<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building H-lang: Testing</title>
    <style>
        :root { --bg: #0d1117; --fg: #c9d1d9; --accent: #00ADD8; --code-bg: #161b22; --border: #30363d; --green: #10b981; }
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; background: var(--bg); color: var(--fg); line-height: 1.6; max-width: 900px; margin: 0 auto; padding: 2rem; }
        h1, h2, h3 { color: var(--accent); }
        h1 { border-bottom: 2px solid var(--border); padding-bottom: 0.5rem; }
        a { color: var(--accent); }
        code { background: var(--code-bg); padding: 0.2rem 0.4rem; border-radius: 4px; font-family: 'Consolas', 'Monaco', monospace; }
        pre { background: var(--code-bg); padding: 1rem; border-radius: 8px; overflow-x: auto; border: 1px solid var(--border); }
        pre code { padding: 0; background: none; }
        .note { background: rgba(0, 173, 216, 0.1); border-left: 4px solid var(--accent); padding: 1rem; margin: 1rem 0; border-radius: 0 8px 8px 0; }
        .success { background: rgba(16, 185, 129, 0.1); border-left: 4px solid var(--green); padding: 1rem; margin: 1rem 0; border-radius: 0 8px 8px 0; }
        nav { display: flex; justify-content: space-between; margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border); }
        nav a { padding: 0.5rem 1rem; background: var(--code-bg); border-radius: 4px; text-decoration: none; }
        nav a:hover { background: var(--border); }
    </style>
</head>
<body>
    <h1>Building H-lang: Testing</h1>
    <p><strong>Part 7: Testing the Compiler</strong></p>

    <h2>Testing Strategy</h2>
    <ul>
        <li><strong>Unit tests</strong> — Test lexer, parser, codegen individually</li>
        <li><strong>Integration tests</strong> — Compile and run H-lang programs</li>
        <li><strong>Golden tests</strong> — Compare output against expected results</li>
    </ul>

    <h2>Lexer Tests</h2>
    <pre><code>// pkg/lexer/lexer_test.go
package lexer

import "testing"

func TestOperators(t *testing.T) {
    input := `:= == != <= >= && || ++ -- += -= *= /=`

    tests := []struct {
        expectedType    TokenType
        expectedLiteral string
    }{
        {WALRUS, ":="},
        {EQ, "=="},
        {NEQ, "!="},
        {LTE, "<="},
        {GTE, ">="},
        {AND, "&&"},
        {OR, "||"},
        {INCREMENT, "++"},
        {DECREMENT, "--"},
        {PLUS_ASSIGN, "+="},
        {MINUS_ASSIGN, "-="},
        {MUL_ASSIGN, "*="},
        {DIV_ASSIGN, "/="},
        {EOF, ""},
    }

    l := New(input)
    for i, tt := range tests {
        tok := l.NextToken()
        if tok.Type != tt.expectedType {
            t.Errorf("tests[%d] - type wrong. expected=%v, got=%v",
                i, tt.expectedType, tok.Type)
        }
    }
}

func TestComments(t *testing.T) {
    input := `
    // C-style single line
    # Shell-style
    /* Multi
       line */
    x := 42;
    `

    l := New(input)

    // Should skip all comments and find x
    tok := l.NextToken()
    for tok.Type == COMMENT {
        tok = l.NextToken()
    }

    if tok.Type != IDENT || tok.Literal != "x" {
        t.Errorf("expected IDENT 'x', got %v '%s'", tok.Type, tok.Literal)
    }
}</code></pre>

    <h2>Parser Tests</h2>
    <pre><code>// pkg/parser/parser_test.go
package parser

import (
    "testing"
    "github.com/Dr-H-PhD/h-lang/pkg/lexer"
    "github.com/Dr-H-PhD/h-lang/pkg/ast"
)

func TestInferStatement(t *testing.T) {
    input := `x := 42;`

    l := lexer.New(input)
    p := New(l)
    program := p.ParseProgram()
    checkParserErrors(t, p)

    if len(program.Statements) != 1 {
        t.Fatalf("expected 1 statement, got %d", len(program.Statements))
    }

    stmt, ok := program.Statements[0].(*ast.InferStatement)
    if !ok {
        t.Fatalf("not InferStatement, got %T", program.Statements[0])
    }

    if stmt.Name.Value != "x" {
        t.Errorf("name not 'x', got %s", stmt.Name.Value)
    }
}

func TestFunctionStatement(t *testing.T) {
    input := `
    public function add(a int, b int) int {
        return a + b;
    }
    `

    l := lexer.New(input)
    p := New(l)
    program := p.ParseProgram()
    checkParserErrors(t, p)

    stmt := program.Statements[0].(*ast.FunctionStatement)

    if !stmt.Public {
        t.Error("expected public function")
    }

    if stmt.Name.Value != "add" {
        t.Errorf("name not 'add', got %s", stmt.Name.Value)
    }

    if len(stmt.Parameters) != 2 {
        t.Errorf("expected 2 params, got %d", len(stmt.Parameters))
    }
}

func TestOperatorPrecedence(t *testing.T) {
    tests := []struct {
        input    string
        expected string
    }{
        {"1 + 2 * 3;", "((1 + (2 * 3)));"},
        {"1 * 2 + 3;", "(((1 * 2) + 3));"},
        {"a + b * c + d;", "(((a + (b * c)) + d));"},
        {"-a * b;", "(((-a) * b));"},
        {"!true == false;", "(((!true) == false));"},
    }

    for _, tt := range tests {
        l := lexer.New(tt.input)
        p := New(l)
        program := p.ParseProgram()
        checkParserErrors(t, p)

        if program.String() != tt.expected {
            t.Errorf("expected=%q, got=%q", tt.expected, program.String())
        }
    }
}

func checkParserErrors(t *testing.T, p *Parser) {
    errors := p.Errors()
    if len(errors) == 0 {
        return
    }
    t.Errorf("parser had %d errors:", len(errors))
    for _, msg := range errors {
        t.Errorf("  %s", msg)
    }
    t.FailNow()
}</code></pre>

    <h2>Integration Tests</h2>
    <pre><code>// test/integration_test.go
package test

import (
    "os"
    "os/exec"
    "strings"
    "testing"
)

func TestHelloWorld(t *testing.T) {
    source := `
    function main() {
        print("Hello, H-lang!");
    }
    `

    output := compileAndRun(t, source)

    expected := "Hello, H-lang!\n"
    if output != expected {
        t.Errorf("expected %q, got %q", expected, output)
    }
}

func TestArithmetic(t *testing.T) {
    source := `
    function main() {
        x := 10 + 20 * 2;
        print(x);
    }
    `

    output := compileAndRun(t, source)

    if strings.TrimSpace(output) != "50" {
        t.Errorf("expected 50, got %s", output)
    }
}

func TestControlFlow(t *testing.T) {
    source := `
    function main() {
        x := 5;
        if x > 0 {
            print("positive");
        } else {
            print("non-positive");
        }
    }
    `

    output := compileAndRun(t, source)

    if strings.TrimSpace(output) != "positive" {
        t.Errorf("expected 'positive', got %s", output)
    }
}

func compileAndRun(t *testing.T, source string) string {
    // Write source to temp file
    tmpFile, _ := os.CreateTemp("", "test-*.hl")
    tmpFile.WriteString(source)
    tmpFile.Close()
    defer os.Remove(tmpFile.Name())

    // Compile
    cmd := exec.Command("hlc", "-o", "test_binary", tmpFile.Name())
    if err := cmd.Run(); err != nil {
        t.Fatalf("compilation failed: %v", err)
    }
    defer os.Remove("test_binary")

    // Run
    output, err := exec.Command("./test_binary").Output()
    if err != nil {
        t.Fatalf("execution failed: %v", err)
    }

    return string(output)
}</code></pre>

    <h2>Running Tests</h2>
    <pre><code># Run all tests
go test ./...

# Run with verbose output
go test -v ./...

# Run specific package
go test -v ./pkg/lexer

# Run with coverage
go test -cover ./...</code></pre>

    <h2>Example Test Run</h2>
    <pre><code>$ go test -v ./pkg/lexer
=== RUN   TestOperators
--- PASS: TestOperators (0.00s)
=== RUN   TestComments
--- PASS: TestComments (0.00s)
=== RUN   TestKeywords
--- PASS: TestKeywords (0.00s)
PASS
ok      github.com/Dr-H-PhD/h-lang/pkg/lexer    0.003s</code></pre>

    <div class="success">
        <strong>Congratulations!</strong>
        <p>You've built a complete compiler for H-lang! The compiler:</p>
        <ul>
            <li>Tokenizes H-lang source with a handwritten lexer</li>
            <li>Parses into an AST using a Pratt parser</li>
            <li>Generates C code from the AST</li>
            <li>Invokes gcc/clang to produce a native binary</li>
        </ul>
    </div>

    <h2>Next Steps</h2>
    <ul>
        <li><strong>Type Checker</strong> — Add semantic analysis</li>
        <li><strong>More Types</strong> — Arrays, slices, maps</li>
        <li><strong>Concurrency</strong> — Channels and goroutines (v2)</li>
        <li><strong>Standard Library</strong> — I/O, strings, math</li>
        <li><strong>Self-Hosting</strong> — Write the compiler in H-lang</li>
    </ul>

    <nav>
        <a href="06-cli.html">← Previous: CLI</a>
        <a href="08-defer.html">Next: Defer →</a>
    </nav>
</body>
</html>
